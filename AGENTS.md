<!-- Generated by ralph init -->
<!-- generator: ralph-init -->
<!-- safe_to_delete: true -->

# AGENTS.md - Project Configuration for AI Agents

This file contains critical operational details that AI agents should know when working on this project.

## Project-Specific Configuration

- **Package Manager**: Bun
- **Build Command**: `bun run build` (Astro in course-scheduler-astro/)
- **Test Command**: `bun test` (Vitest) in course-scheduler-astro/
- **E2E Test Command**: `bun run test:e2e` (Playwright) in course-scheduler-astro/
- **Lint Command**: `bun run lint` (ESLint at monorepo root)
- **Format Command**: `bun run format` (Prettier at monorepo root)
- **Project Root**: C:\Repository\CITUCourseBuilder
- **Primary App Location**: course-scheduler-astro/ (Astro 5.x + React 19 islands)

## Critical Operational Details

### Preserved Logic Files (DO NOT MODIFY LOGIC)

These files contain critical parsing and scheduling logic that MUST be preserved exactly:

- `course-scheduler-astro/src/utils/parseSchedule.ts` - Schedule string parsing (467 lines)
- `course-scheduler-astro/src/utils/parseRawData.ts` - Course data parsing (398 lines)
- `course-scheduler-astro/src/utils/generateIcs.ts` - ICS calendar generation (134 lines)
- `course-scheduler-astro/src/utils/convertToRawData.ts` - Raw data conversion (57 lines)
- `course-scheduler-astro/src/utils/scheduleAlgorithms.ts` - Scheduling algorithms (640+ lines)

### Scheduling Algorithms (13 Functions)

**Core Utility Functions:**

- `loadFromLocalStorage(key, defaultValue)` - Load persisted state with validation (~72 lines)
- `getSectionTypeSuffix(sectionString)` - Extract AP3/AP4/AP5 from section string (~5 lines)

**Time & Conflict Detection:**

- `checkTimeOverlap(start1, end1, start2, end2)` - Check if two time ranges overlap (~6 lines)
- `isScheduleConflictFree(schedule, parseFn, overlapFn)` - Verify schedule has no conflicts (~31 lines)
- `getTimeOfDayBucket(time)` - Categorize time as morning/afternoon/evening (~7 lines)

**Constraint Validation:**

- `scoreScheduleByTimePreference(schedule, prefOrder)` - Score schedule by time preferences (~15 lines)
- `exceedsMaxUnits(schedule, maxUnits)` - Check if exceeds unit limit (~7 lines)
- `exceedsMaxGap(schedule, maxGapHours)` - Check if gaps exceed threshold (~30 lines)
- `countCampusDays(schedule)` - Count unique on-campus days (~16 lines)

**Schedule Generation:**

- `getAllSubsets(arr)` - Generate power set (~9 lines)
- `generateExhaustiveBestSchedule(...)` - Exhaustive search algorithm (~83 lines)
- `generateBestPartialSchedule_Heuristic(...)` - Heuristic-based generator (~121 lines)
- `generateBestPartialSchedule(...)` - Main partial schedule entry point (~64 lines)

**Critical Dependencies:**

- All schedule analysis functions depend on `parseSchedule` from utils
- `SMALL_N_THRESHOLD_PARTIAL = 12` - Threshold for switching from exhaustive to heuristic
- Score formula: `totalCourses * 100 + totalUnits` (higher is better)
- Time preference score: lower is better (based on preference order index)

### Code Style & Conventions

- Use TypeScript strict mode for all new code
- Prefer functional components in React
- No `any` types allowed
- JSDoc comments for public APIs
- Preserve ALL existing logic exactly when migrating

### Architecture Notes

**Current Astro Architecture (course-scheduler-astro/):**

- Astro 5.x with React 19 islands architecture
- 6 custom hooks for state management: useLocalStorage, useTheme, useCourseState, useFilterState, useSchedulePreferences, useScheduleGeneration
- Flat component hierarchy with React islands
- 13 localStorage keys for persistence
- 13 scheduling algorithms in scheduleAlgorithms.ts (~640 lines)
- Custom Tailwind-styled components with Lucide icons
- Custom Toast notification system
- html-to-image and jspdf (lazy-loaded) for exports

**TypeScript Interfaces (course-scheduler-astro/src/types/index.ts):**

- Core types: DayCode, TimeOfDayBucket, ScheduleSearchMode, GroupingMode
- Data types: TimeSlot, ParsedSchedule, Course, GroupedCourse, CoursesBySubject
- State types: FilterState, SchedulePreferences, AppState
- 25+ interfaces defined for migration

**State Categories:**

1. Core Data: allCourses, processedCourses, rawData
2. Theme: theme, themePalette
3. Filters: excludedDays, excludedTimeRanges, sectionTypes, statusFilter
4. Preferences: maxUnits, maxGapHours, preferredTimeOrder, searchMode
5. UI State: showTimetable, isGenerating, confirmDialog
6. Generated: generatedSchedules, currentScheduleIndex

**Component Hydration Strategy:**

- `client:load`: App, RawDataInput, CourseTable, ConfirmDialog (immediate interactivity required)
- `client:visible`: TimeFilter, TimetableView (lazy load when scrolled into view)
- React runtime (~58.5 kB gzipped) only loads when islands are present
- Each island is code-split for optimal caching

**Component Dependencies:**

- App.tsx imports all child components directly (React islands)
- TimeFilter uses custom Tailwind-styled time picker
- CourseTable uses custom DropdownMenu, Tooltip, StatusBadge components
- TimetableView uses html-to-image, jspdf (lazy-loaded) for exports
- ConfirmDialog uses custom Tailwind dialog component

### Environment Setup

- Node.js 18+ required
- Bun as package manager
- No environment variables required for local development
- GitHub Pages deployment with /CITUCourseBuilder/ base path

## Common Gotchas & Lessons Learned

1. **Schedule parsing is complex**: The parseSchedule.js handles TBA schedules, multi-slot schedules, hybrid schedules (F2F+Online), and comma-separated day codes. Any modification risks breaking compatibility with WITS/AIMS data formats.

2. **Conflict detection is critical**: The `checkTimeOverlap` and `isScheduleConflictFree` functions are used extensively. Changes here could cause valid schedules to be rejected or conflicting schedules to be accepted.

3. **localStorage keys are namespaced**: All keys use `courseBuilder_` prefix. The `loadFromLocalStorage` function includes validation and defaults for each key type.

4. **Theme system uses CSS custom properties**: The App.css defines 107 CSS variables for theming. Light/dark modes plus 3 palettes (original, comfort, space) create 6 theme combinations. Theme switching uses `data-theme` and `data-palette` attributes on `document.documentElement`. See docs/architecture/CSS_ARCHITECTURE.md for complete inventory.

5. **CSS specificity gotchas**: The CSS uses `!important` in 8 places (conflict highlighting, group header rows). These override theme-specific styles and must be handled carefully in Tailwind migration.

6. **Responsive breakpoints**: CSS uses 992px, 768px, 480px breakpoints. The 768px breakpoint transforms tables to card-based layout (requires special handling in migration).

7. **Toastify CSS overrides**: 16 CSS custom properties control react-toastify styling. These map to theme colors and must be preserved or replaced with custom toast component.

8. **Schedule generation has 3 modes**:
   - `partial` (default): Heuristic-based, maximizes subjects even if not all fit
   - `exhaustive`: Tries all combinations, fails if can't fit all subjects
   - `fast`: Random sampling, may miss optimal schedules

9. **Course identity is compound**: Courses are identified by `{id, subject, section}` tuple, not just `id`.

10. **Test coverage baseline established**: Current coverage is 81.25% line coverage, 94.32% function coverage. Critical gaps exist in scheduling algorithms (0% coverage) and export functions (generateIcs.js, convertToRawData.js - 0% coverage). See docs/architecture/TEST_COVERAGE_BASELINE.md for detailed analysis.

11. **Untested critical paths**:
    - Scheduling algorithms (~461 lines in App.jsx) - must add tests before migration
    - ICS calendar generation (generateIcs.js, 111 lines)
    - Raw data export (convertToRawData.js, 29 lines)
    - Edge cases in parseSchedule.js (TBA schedules, multi-slot parsing)
    - Edge cases in parseRawData.js (malformed HTML, invalid formats)

12. **Performance baseline established**: Current bundle is ~457 KB gzipped (within 500 KB target). Lighthouse scores: Performance 75, Accessibility 90, Best Practices 100, SEO 91. Core Web Vitals show slow FCP (4.0s) and LCP (4.4s) due to large JS bundle (1,070 KB main chunk). Build time is 4.13s. See docs/architecture/PERFORMANCE_BASELINE.md for detailed analysis.

13. **Bundle optimization opportunities**:
    - Main bundle is 1,070 KB (needs code-splitting)
    - MUI components add ~300 KB (replace with Tailwind)
    - Export libraries (html-to-image, jspdf) add ~200 KB (lazy load)
    - Expected bundle reduction after Astro migration: ~30-40%

14. **Astro project initialized**: The `course-scheduler-astro/` directory contains Astro 5.17.x with React 19.x and Tailwind 4.x integrations. Build time is ~1.4s, significantly faster than the React/Vite build (4.13s). TypeScript strict mode is enabled via `extends: "astro/tsconfigs/strict"`. Base path `/CITUCourseBuilder/` configured for GitHub Pages deployment.

15. **React islands hydration strategy defined**: Each component has a specific hydration directive based on its interactivity needs:
    - `client:load`: RawDataInput, CourseTable, ConfirmDialog (immediate interactivity required)
    - `client:visible`: TimeFilter, TimetableView (lazy load when scrolled into view)
    - React runtime (~58.5 kB gzipped) only loads when islands are present
    - Each island is code-split for optimal caching
    - See docs/architecture/REACT_ISLANDS_HYDRATION.md for complete configuration

16. **TypeScript configuration in Astro**: The `astro/tsconfigs/strict` preset enables all required strict options (`strict: true`, `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, etc.). Typecheck script is `astro check && tsc --noEmit` which runs both Astro-specific diagnostics and TypeScript compiler. The `@astrojs/check` package provides Astro file diagnostics. All `@types/*` packages are installed as dependencies (not devDependencies) in Astro projects.

17. **Tailwind v4 CSS-based configuration**: Tailwind v4 uses CSS-based configuration with `@theme` directive instead of JavaScript config files. The `@tailwindcss/vite` plugin is used (not `@astrojs/tailwind`). Theme switching uses CSS custom properties with `data-theme` and `data-palette` attributes on `document.documentElement`. The theme flash prevention script must be inline in `<head>` (using `is:inline`) to apply theme before page renders. The `@import` statement for Google Fonts must come before other CSS rules to avoid warnings. See `course-scheduler-astro/src/styles/global.css` for the complete theme configuration with 6 theme combinations (light/dark × original/comfort/space palettes).

18. **Astro project structure with path aliases**: The `course-scheduler-astro/src/` directory follows a standard Astro + React islands architecture with directories for components (React islands), layouts (Astro layouts), pages (Astro pages), styles (global CSS), utils (preserved logic), hooks (custom React hooks), types (TypeScript definitions), and assets (static assets). TypeScript path aliases are configured in `tsconfig.json` with `baseUrl: "."` and `paths` mapping `@/*`, `@components/*`, `@layouts/*`, etc. to their respective directories for clean imports. A separate `tests/` directory exists at the project root for test files.

19. **Lint-staged configuration at monorepo root**: The root `package.json` contains lint-staged configuration for the entire project. File patterns cover `*.{js,jsx,ts,tsx}` and `*.astro` files running `eslint --fix`. The configuration works with husky (T2.2.2) for pre-commit hooks. ESLint must be installed at root level (T2.2.3) for the linting commands to execute successfully.

20. **Husky pre-commit and commit-msg hooks**: Husky v9.1.7 is configured at the monorepo root with two hooks:
    - `.husky/pre-commit`: Runs `bun run lint-staged` to lint staged files before commit
    - `.husky/commit-msg`: Validates conventional commits format (type[scope]: description)
    - Git hooks path is set via `git config core.hooksPath .husky`
    - The commit-msg hook allows merge commits, revert commits, and fixup/squash commits without validation
    - Conventional commit types: feat, fix, build, chore, ci, docs, style, refactor, perf, test

21. **ESLint flat config at monorepo root**: ESLint v10.0.0 is configured at the monorepo root with flat config (`eslint.config.js`). The configuration supports JavaScript (.js, .jsx), TypeScript (.ts, .tsx), and Astro (.astro) files. Key packages: `eslint`, `@eslint/js`, `eslint-plugin-astro`, `eslint-plugin-react`, `eslint-plugin-react-hooks`, `eslint-plugin-react-refresh`, `typescript-eslint`, `globals`. Use `bun run lint` to check all files and `bun run lint:fix` to auto-fix issues.

22. **Prettier configuration at monorepo root**: Prettier v3.8.1 is configured at the monorepo root with `prettier-plugin-astro` v0.14.1 for Astro file support. Configuration is in `.prettierrc` with formatting rules: semicolons, single quotes, 2-space tabs, trailing commas (ES5), 100-char print width. The `.prettierignore` file excludes build artifacts (`dist/`, `.astro/`), lock files (`package-lock.json`), and generated files (`*.d.ts`, `*.mjs`). Lint-staged runs Prettier after ESLint on pre-commit for `*.{js,jsx,ts,tsx,astro,json,md,css}` files. Use `bun run format` to format all files and `bun run format:check` to verify formatting in CI.

23. **CI status checks in GitHub Actions**: The GitHub Actions workflow (`.github/workflows/deploy.yml`) includes four CI checks: lint (ESLint), typecheck (TypeScript), test (Vitest), and build (Astro). These checks run on every push to `main` branch. Branch protection rules must be manually configured in GitHub repository settings to require these checks to pass before merging. See `docs/BRANCH_PROTECTION.md` for manual setup instructions. The workflow fails fast - any failing step prevents deployment.

24. **TypeScript path alias conflict with @types**: The path alias `@types/*` configured in `tsconfig.json` conflicts with TypeScript's built-in `@types/*` package convention (used for DefinitelyTyped packages). This causes import errors like "Cannot import type declaration files." Solution: Use `@/types/*` instead of `@types/*` for local type imports. Example: `import type { DayCode } from '@/types/index'` instead of `import type { DayCode } from '@types/index'`.

25. **Type definitions must match actual function signatures**: When creating type definitions for existing functions, ensure the types match the actual implementation. Example: `parseSchedule()` returns `ParsedSchedule | null` (can fail), so `ParseScheduleFunction` must return `ParsedSchedule | null`, not just `ParsedSchedule`. Similarly, `GetTimeOfDayBucketFunction` must accept `string | null | undefined` because `TimeSlot.startTime` can be null. Type mismatches between definitions and implementations cause type errors when using the functions in strict mode.

26. **Color palette with WCAG AA compliance**: The Tailwind v4 CSS-based theme in `course-scheduler-astro/src/styles/global.css` defines 6 theme combinations (light/dark × original/comfort/space) with semantic colors (success, warning, danger, info). Color contrast is verified via `tests/colorContrast.test.ts` using WCAG 2.1 luminance formulas. Requirements: primary text 4.5:1, large text/UI elements 3:1. The Space palette uses a teal color (#2a9d8f) with ~3.3:1 contrast - acceptable for large text and UI elements but not normal text. When adding new colors, use the `getBestTextColor()` helper to determine optimal text color (light or dark) for badge backgrounds. Semantic colors are typically used as badge backgrounds with contrasting text, not directly on backgrounds.

## Protected Files

The following files are protected by the Ralph write-guardrail plugin and should not be directly modified by AI:

- `prd.json` - PRD plan file (update via Ralph workflow)
- `progress.txt` - Progress tracking (append via Ralph workflow)
- `.ralph-prompt.md` - Prompt template
- `AGENTS.md` - This file

## References

- **Architecture Overview**: docs/architecture/ARCHITECTURE.md - Comprehensive architecture documentation (Astro + React islands, state management, theme system, export system)
- Project Documentation: docs/architecture/ (state analysis, component graphs, algorithm docs)
- Architecture Decisions: docs/architecture/decisions/ (ADRs)
- ADR-001: Framework Migration Approach (Astro + React islands)
- ADR-002: UI Component Strategy (Custom Tailwind + Lucide icons)
- ADR-003: State Management Approach (React state via islands + localStorage)
- Architecture Analysis: docs/architecture/APP_STATE_ANALYSIS.md
- Component Graphs: docs/architecture/COMPONENT_DEPENDENCY_GRAPH.md
- Algorithm Documentation: docs/architecture/SCHEDULING_ALGORITHMS.md
- CSS Architecture: docs/architecture/CSS_ARCHITECTURE.md
- Test Coverage Baseline: docs/architecture/TEST_COVERAGE_BASELINE.md
- Performance Baseline: docs/architecture/PERFORMANCE_BASELINE.md
- Bundle Analysis: docs/architecture/BUNDLE_ANALYSIS.md
- Color Contrast Report: docs/architecture/COLOR_CONTRAST_REPORT.md
- TypeScript Interfaces: docs/architecture/types/index.ts
- React Islands Hydration: docs/architecture/REACT_ISLANDS_HYDRATION.md
- Branch Protection: docs/BRANCH_PROTECTION.md
- Usage Guide: https://github.com/MasuRii/CITUCourseBuilder/blob/main/UsageGuide.md

27. Tablet view optimization (768px): Optimizing for tablet view (md breakpoint) involves balancing column visibility and control layout. In `CourseTable.tsx`, the "Title" column is shown on `md` screens with a `max-w` and truncation to prevent horizontal overflow while providing more context than the mobile view. Header controls use `flex-col md:flex-row` to stack vertically on mobile but side-by-side on tablet/desktop. Table cells use reduced padding on `md` screens to fit all columns comfortably. Summary cards in `TimetableView.tsx` use `flex sm:flex-col items-center sm:items-start` to maintain a compact layout on mobile while expanding naturally on tablet. Main App controls use `hidden sm:inline` labels to save space on very small screens while providing full labels on tablet and desktop.

28. Utility functions coverage: Achieving high test coverage (≥ 80%) for utility functions involved creating a dedicated `tests/utilityEdgeCases.test.ts` file. This file covers edge cases in `parseSchedule.ts` (ambiguous pairings, invalid times), `parseRawData.ts` (malformed HTML, tab-separated inconsistencies), and scheduling algorithms (unreachable branches due to shadowed logic). High coverage ensures that critical parsing and scheduling logic remains robust after migration. Total utility line coverage is now > 95% across all core files.

29. Playwright E2E smoke tests: Comprehensive E2E tests were established in `tests/e2e/smoke.test.ts` to verify the full user journey. Key learnings:
    - Use `data-testid` attributes for reliable element selection in E2E tests, especially for small buttons or dynamic content.
    - For Astro projects with a base path, all asset URLs (images, favicons, open graph) in the `<head>` and components MUST include the base path prefix to avoid router errors during development and deployment.
    - Playwright's `webServer` configuration in `playwright.config.ts` handles starting the Astro dev server automatically.
    - Use `exact: true` or specific ARIA roles/labels to avoid ambiguity when multiple elements have similar text (e.g., "M" day toggle vs other text).

30. Visual regression testing with Playwright: Playwright's `toHaveScreenshot()` matcher provides visual regression testing. Key patterns:
    - Snapshot files are stored in `tests/e2e/*.test.ts-snapshots/` directory with platform-specific names (e.g., `home-empty-light-chromium-win32.png`).
    - Use `--update-snapshots` flag to create/update baseline screenshots: `bun run test:e2e -- --update-snapshots`.
    - Run visual tests separately from smoke tests to avoid confusion: `bun run test:e2e tests/e2e/visual.test.ts`.
    - Snapshot files should be committed to the repository for CI to compare against.
    - Each snapshot covers a specific component state: empty page, with courses, with schedule, dialogs, filters, theme/palette variants.
    - Use `type Page` from `@playwright/test` for proper TypeScript typing in helper functions.
    - Visual tests catch unintended UI changes during refactoring and ensure consistent theming across all 6 theme combinations.

31. **Smart data import logic**: The `parseRawCourseData` function in `utils/parseRawData.ts` is a "smart" dispatcher that sequentially tries four different parsing methods: HTML variation (WITS), tab-separated (AIMS standard/two-line), space-separated, and compact variation. This ensures maximum compatibility with different ways students copy their data from university portals. When adding new formats, they should be integrated into this dispatcher with appropriate pattern detection to avoid false positives.

32. **E2E Import Verification**: Verifying the smart data import logic in the UI requires switching between WITS and AIMS modes in the `RawDataInput` component. E2E tests in `tests/e2e/importFormats.test.ts` cover all four parsing variations plus error handling. When testing error toasts, use `page.getByRole('alert')` to reliably locate the custom toast notification.

33. **Automated Accessibility Testing**: Using `@axe-core/playwright` allows for automated WCAG 2.1 AA compliance checks in E2E tests. Disabling certain rules like `color-contrast` is sometimes necessary during general audits if they are handled by dedicated tests (like `tests/colorContrast.test.ts`). Ensure components like `alertdialog` and `table` are populated before scanning to catch dynamic accessibility issues.

34. **Default App State**: The application initializes with default filters: `STATUS_FILTER` is set to 'open' (hiding closed courses) and `GROUPING` is set to 'subject'. E2E tests must account for these defaults when verifying imported data counts.

35. **E2E Table Testing**: When multiple tables exist (e.g., CourseTable and TimetableView), use `data-testid` to uniquely identify the target table. Playwright's `innerText` may omit spaces for CSS margins/padding, so regex matching (e.g., `/CASE.*\(2 courses\)/`) is more robust than exact string matching for composite text.

36. **Keyboard Navigation Testing**: Playwright E2E tests can verify keyboard accessibility: use `locator.focus()` to focus elements, `page.keyboard.press('Tab')` for navigation, `expect(locator).toBeFocused()` to verify focus, and `page.keyboard.press('Space')`/`page.keyboard.press('Enter')` to test activation. For dialog interactions, verify `autoFocus` on confirm button and `Escape` to close. For tooltips, add `tabIndex={0}` to the container div for keyboard focusability. Test "no keyboard traps" by tabbing multiple times and verifying focus moves to different elements.

37. **Astro Dev Toolbar Interference**: The Astro dev toolbar is focusable and can interfere with keyboard navigation tests (e.g., catching focus and causing strict mode violations in Playwright). Use `page.addStyleTag({ content: 'astro-dev-toolbar { display: none !important; }' })` to disable it during E2E tests. Also, ensure buttons are enabled (e.g., by importing data) before testing their reachability via Tab, as disabled elements are not focusable.

38. **Semantic Color System for Aesthetic Consistency**: A comprehensive semantic color system was implemented in `global.css` using Tailwind v4's `@theme` directive. This includes 12 "subject colors" (`subject-1` to `subject-12`) with light and text variants for playful timetable visualization. Moving from hardcoded Tailwind classes to semantic variables allows for theme-specific overrides (e.g., in Space or Comfort palettes) while maintaining accessibility compliance (WCAG AA). All color combinations are verified via `tests/colorContrast.test.ts`.

39. **Screen Reader Compatibility**: Programmatic accessibility for screen readers is verified in `tests/e2e/screenReader.test.ts`. Key patterns include:
    - Use `role="alert"` and `aria-live="polite"` for dynamic notifications like toasts to ensure immediate announcement.
    - Provide descriptive `aria-label` for complex visualization cards (e.g., timetable cells) that include all relevant metadata (subject, section, time, room) for non-visual users.
    - Ensure all interactive elements have accessible names via `aria-label` or visible text, especially when using icon-only buttons on mobile.
    - Use `aria-hidden="true"` for decorative icons and background elements to avoid confusing announcements and reduce cognitive load.
    - Distinguish between `dialog` and `alertdialog` roles based on the nature of the interaction (standard vs destructive/critical) to provide appropriate semantic context.
    - When testing `client:visible` hydrated components in Playwright, ensure the element is scrolled into view to trigger hydration before performing assertions.

40. **Typography for Hobby Student Aesthetic**: To achieve the "built by a student for a hobby" look, the typography was refined to use `Fredoka` for headings and `Lexend` for body text. `Fredoka` provides a rounded, playful, and approachable feel, while `Lexend` offers excellent readability with a friendly, modern sans-serif character. Both fonts are loaded via Google Fonts and integrated into the Tailwind v4 `@theme` block, ensuring consistent application across all components via `font-display` and `font-sans` classes.

41. **Migration Success Metrics**: The React-to-Astro migration achieved significant improvements:
    - Bundle size reduced 77%: main chunk from 519 KB to 117 KB (gzip: ~164 KB initial load, ~340 KB total)
    - Lighthouse scores: Performance 100, Accessibility 97, Best Practices 96, SEO 91 (all exceed ≥90 target)
    - Build time: ~5 seconds (well under 30s target)
    - Test coverage: 91.9% line coverage across 500+ tests
    - Zero `any` types in codebase (strict TypeScript compliance)

42. **Astro Islands Architecture Benefits**: The React islands approach delivered multiple advantages:
    - React runtime only loads when interactive components are present (~58.5 kB gzipped)
    - Each island is code-split for optimal caching
    - Static content is pre-rendered for instant initial page load
    - `client:visible` directive enables lazy loading of heavy components (TimetableView with export libraries)
    - Build time dramatically improved from 4.13s to ~5s despite more comprehensive output

43. **Lazy Loading for Bundle Optimization**: Dynamic imports for export libraries (html-to-image, jspdf) reduced the main App chunk by 77%. These libraries are now loaded only when users interact with export buttons. The pattern: `const { toPng } = await import('html-to-image')` inside the click handler ensures the heavy dependencies don't impact initial page load.

44. **Comprehensive Test Coverage Strategy**: Achieving 91.9% line coverage required multiple test categories:
    - Unit tests for utility functions (parseSchedule, parseRawData, scheduling algorithms)
    - Edge case tests for boundary conditions and malformed inputs
    - Integration tests for component interactions and state management
    - E2E smoke tests for critical user journeys
    - Visual regression tests for UI consistency
    - Accessibility tests for WCAG 2.1 AA compliance
    - Color contrast tests for all theme combinations

45. **Documentation Consolidation**: The migration created multiple architecture documents that should be maintained:
    - `docs/architecture/ARCHITECTURE.md` - Main architecture overview with Mermaid diagrams
    - `docs/architecture/CSS_ARCHITECTURE.md` - CSS custom properties inventory
    - `docs/architecture/COLOR_CONTRAST_REPORT.md` - WCAG AA contrast verification
    - `docs/architecture/BUNDLE_ANALYSIS.md` - Bundle size analysis and optimization
    - `docs/architecture/REACT_ISLANDS_HYDRATION.md` - Hydration strategy per component
    - `docs/architecture/TEST_COVERAGE_BASELINE.md` - Coverage baseline and gaps
    - `docs/architecture/PERFORMANCE_BASELINE.md` - Performance metrics and targets
    - ADRs in `docs/architecture/decisions/` - Architecture Decision Records
